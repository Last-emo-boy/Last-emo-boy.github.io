
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Cross-chain Bridge | w33d&#39;s blog</title>
        <meta name="author" content="last emo boy" />
        <meta name="description" content="Harbor for the last emo boy" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/obsidian.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>W33D&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;W33D&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1>Cross-chain Bridge</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/5
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Coding/" style="color: #ffa2c4">Coding</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>区块链是一种分布式的数据库技术，它可以实现去中心化、安全和透明的数据存储和交换。区块链上的数据是以区块的形式组织的，每个区块都包含了一些交易记录，这些交易记录是由网络中的参与者通过共识机制验证并达成一致的。每个区块都会链接到前一个区块，形成一个不可篡改的链式结构，这就是区块链的名字的由来。</p>
<span id="more"></span>
<p>目前，已经有很多不同的区块链网络存在，比如比特币、以太坊、波卡等。这些网络都有自己的特点和优势，比如安全性、速度、灵活性等。然而，这些网络之间也存在着隔离和不兼容的问题，也就是说，它们无法直接互相通信和交换数据。这就限制了区块链技术的潜力和应用场景，因为很多时候我们需要在不同的网络之间实现数据和价值的流动和转移。</p>
<p>为了解决这个问题，就出现了一种叫做跨链桥（cross-chain
bridge）的技术。跨链桥是一种连接不同区块链网络的基础设施协议，它可以实现在两个或多个网络之间安全地转移资产或数据。跨链桥可以让用户在不同的网络上使用同一种资产或服务，从而增加了区块链的互操作性（interoperability）和流动性（liquidity）。</p>
<p>跨链桥通常会利用预言机来监听两个网络上发生的事件，并根据事件触发相应的操作。例如，如果用户想要将以太坊上的ETH转移到波卡上，那么他需要在以太坊上调用一个智能合约（smart
contract），并将ETH锁定在合约中。然后预言机会监听到这个事件，并将其通知到波卡上的另一个智能合约。这个合约会验证事件的有效性，并在波卡上铸造相应数量的ETH代币（token），并转给用户。反之亦然，如果用户想要将波卡上的ETH转移到以太坊上，那么他需要在波卡上销毁ETH代币，并通过预言机通知以太坊上的合约解锁ETH并转给用户。</p>
<p>下面是一个简单的示例代码，展示了如何在以太坊和波卡之间实现跨链桥功能：</p>
<pre class="solidity"><code>// 以太坊上的智能合约
pragma solidity ^0.8.0;

contract EthBridge {
    // 预言机地址
    address public oracle;
    // 波卡地址到以太坊地址的映射
    mapping (address =&gt; address) public polkaToEth;
    // 以太坊地址到波卡地址的映射
    mapping (address =&gt; address) public ethToPolka;
    // ETH代币的地址
    address public ethToken;

    // 构造函数，设置预言机地址和ETH代币地址
    constructor(address _oracle, address _ethToken) {
        oracle = _oracle;
        ethToken = _ethToken;
    }

    // 注册函数，用户需要提供自己的波卡地址，并授权合约转移ETH
    function register(address polkaAddress) public {
        require(polkaToEth[polkaAddress] == address(0), "Already registered");
        require(ethToPolka[msg.sender] == address(0), "Already registered");
        polkaToEth[polkaAddress] = msg.sender;
        ethToPolka[msg.sender] = polkaAddress;
        IERC20(ethToken).approve(address(this), type(uint256).max);
    }

    // 跨链转账函数，用户需要指定转账金额和目标波卡地址
    function transfer(uint256 amount, address to) public {
        require(polkaToEth[to] != address(0), "Invalid polka address");
        require(IERC20(ethToken).balanceOf(msg.sender) &gt;= amount, "Insufficient balance");
        IERC20(ethToken).transferFrom(msg.sender, address(this), amount);
        emit Transfer(msg.sender, to, amount);
    }

    // 预言机回调函数，只能由预言机调用，用于解锁ETH并转给用户
    function unlock(address from, address to, uint256 amount) public {
        require(msg.sender == oracle, "Only oracle can call");
        require(ethToPolka[to] != address(0), "Invalid eth address");
        require(IERC20(ethToken).balanceOf(address(this)) &gt;= amount, "Insufficient balance");
        IERC20(ethToken).transfer(to, amount);
        emit Unlock(from, to, amount);
    }

    // 跨链转账事件，包含转出地址、转入地址和金额
    event Transfer(address indexed from, address indexed to, uint256 amount);

    // 跨链解锁事件，包含转出地址、转入地址和金额
    event Unlock(address indexed from, address indexed to, uint256 amount);
}</code></pre>
<pre class="rust"><code>// 波卡上的智能合约
#![cfg_attr(not(feature = "std"), no_std)]

use frame_support::{decl_module, decl_storage, decl_event, decl_error, dispatch};
use frame_system::ensure_signed;
use sp_std::prelude::*;
use pallet_balances::traits::Currency;

// ETH代币的类型定义
type EthToken&lt;T&gt; = pallet_generic_asset::Module&lt;T&gt;;

// 模块的配置接口
pub trait Config: pallet_generic_asset::Config {
    // 预言机类型
    type Oracle: frame_system::Config;
    // 事件类型
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as frame_system::Config&gt;::Event&gt;;
}

// 模块的存储项
decl_storage! {
    trait Store for Module&lt;T: Config&gt; as PolkaBridge {
        // 以太坊地址到波卡地址的映射
        EthToPolka get(fn eth_to_polka): map hasher(blake2_128_concat) Vec&lt;u8&gt; =&gt; T::AccountId;
        // 波卡地址到以太坊地址的映射
        PolkaToEth get(fn polka_to_eth): map hasher(blake2_128_concat) T::AccountId =&gt; Vec&lt;u8&gt;;
        // ETH代币的ID
        EthTokenId get(fn eth_token_id): T::AssetId;
    }
}

// 模块的事件
decl_event!(
    pub enum Event&lt;T&gt; where AccountId = &lt;T as frame_system::Config&gt;::AccountId {
        // 注册事件，包含波卡地址和以太坊地址
        Registered(AccountId, Vec&lt;u8&gt;),
        // 跨链转账事件，包含转出地址、转入地址和金额
        Transfer(AccountId, Vec&lt;u8&gt;, u64),
        // 跨链解锁事件，包含转出地址、转入地址和金额
        Unlock(Vec&lt;u8&gt;, AccountId, u64),
    }
);

// 模块的错误类型
decl_error! {
    pub enum Error for Module&lt;T: Config&gt; {
        // 已经注册过的错误
        AlreadyRegistered,
        // 无效的以太坊地址错误
        InvalidEthAddress,
        // 余额不足的错误
        InsufficientBalance,
        // 只有预言机可以调用的错误
        OnlyOracleCanCall,
    }
}

// 模块的调度函数
decl_module! {
    pub struct Module&lt;T: Config&gt; for enum Call where origin: T::Origin {
        // 初始化事件
        fn deposit_event() = default;

        // 注册函数，用户需要提供自己的以太坊地址，并授权合约转移ETH代币
        #[weight = 10_000]
        fn register(origin, eth_address: Vec&lt;u8&gt;) -&gt; dispatch::DispatchResult {
            let sender = ensure_signed(origin)?;
            ensure!(EthToPolka::&lt;T&gt;::contains_key(&amp;eth_address) == false, Error::&lt;T&gt;::AlreadyRegistered);
            ensure!(PolkaToEth::&lt;T&gt;::contains_key(&amp;sender) == false, Error::&lt;T&gt;::AlreadyRegistered);
            EthToPolka::&lt;T&gt;::insert(&amp;eth_address, &amp;sender);
            PolkaToEth::&lt;T&gt;::insert(&amp;sender, &amp;eth_address);
            EthToken::&lt;T&gt;::approve_transfer(sender.clone(), Self::account_id(), u64::MAX)?;
            Self::deposit_event(RawEvent::Registered(sender, eth_address));
            Ok(())
        }

        // 跨链转账函数，用户需要指定转账金额和目标以太坊地址
        #[weight = 10_000]
        fn transfer(origin, amount: u64, to: Vec&lt;u8&gt;) -&gt; dispatch::DispatchResult {
            let sender = ensure_signed(origin)?;
            ensure!(EthToPolka::&lt;T&gt;::contains_key(&amp;to), Error::&lt;T&gt;::InvalidEthAddress);
            ensure!(EthToken::&lt;T&gt;::free_balance(&amp;sender) &gt;= amount, Error::&lt;T&gt;::InsufficientBalance);
            EthToken::&lt;T&gt;::make_transfer(Self::account_id(), sender.clone(), amount)?;
            Self::deposit_event(RawEvent::Transfer(sender, to, amount));
            Ok(())
        }

        // 预言机回调函数，只能由预言机调用，用于铸造ETH代币并转给用户
        #[weight = 10_000]
        fn mint(origin, from: Vec&lt;u8&gt;, to: T::AccountId, amount: u64) -&gt; dispatch::DispatchResult {
            let sender = ensure_signed(origin)?;
            ensure!(sender == T::Oracle::get(), Error::&lt;T&gt;::OnlyOracleCanCall);
            ensure!(PolkaToEth::&lt;T&gt;::contains_key(&amp;to), Error::&lt;T&gt;::InvalidEthAddress);
            EthToken::&lt;T&gt;::mint(Self::account_id(), amount)?;
            EthToken::&lt;T&gt;::make_transfer(Self::account_id(), to.clone(), amount)?;
            Self::deposit_event(RawEvent::Mint(from, to, amount));
            Ok(())
        }

        // 预言机回调函数，只能由预言机调用，用于销毁ETH代币并通知以太坊合约解锁ETH
        #[weight = 10_000]
        fn burn(origin, from: T::AccountId, to: Vec&lt;u8&gt;, amount: u64) -&gt; dispatch::DispatchResult {
            let sender = ensure_signed(origin)?;
            ensure!(sender == T::Oracle::get(), Error::&lt;T&gt;::OnlyOracleCanCall);
            ensure!(EthToPolka::&lt;T&gt;::contains_key(&amp;to), Error::&lt;T&gt;::InvalidEthAddress);
            EthToken::&lt;T&gt;::burn(Self::account_id(), amount)?;
            EthToken::&lt;T&gt;::make_transfer(from.clone(), Self::account_id(), amount)?;
            Self::deposit_event(RawEvent::Burn(from, to, amount));
            Ok(())
        }
    }
}</code></pre>
<p>这样就完成了波卡上的智能合约的代码。这个合约可以实现以下功能：<br>
-
用户可以通过注册函数，提供自己的以太坊地址，并授权合约转移ETH代币。<br>
-
用户可以通过转账函数，指定转账金额和目标以太坊地址，将自己的ETH代币锁定在合约中，并触发跨链转账事件。<br>
-
预言机可以通过铸造函数，根据以太坊上的事件，为用户在波卡上铸造相应数量的ETH代币，并转给用户，并触发跨链铸造事件。<br>
-
预言机可以通过销毁函数，根据用户的请求，为用户在波卡上销毁相应数量的ETH代币，并通知以太坊上的合约解锁ETH，并转给用户，并触发跨链销毁事件。</p>
<p>这样，我们就实现了一个简单的跨链桥协议，可以在以太坊和波卡之间安全地转移ETH资产。</p>
<p>跨链桥的类型主要有三种，我们前面提到的这种方式被称为：</p>
<ul>
<li><p>锁定/铸造（Lock/Mint）：这种类型的跨链桥利用预言机（Oracle）的技术，实现在起始链上锁定资产，并在目标链上铸造相应数量的代币。预言机是一种能够将区块链外部的数据引入到区块链内部，并保证其正确性和可信度的系统。锁定/铸造的过程如下：</p>
<ul>
<li>用户 A 在起始链上调用一个智能合约（Smart Contract），并将 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span> 个资产 A 锁定在合约中。</li>
<li>预言机监听到这个事件，并将其通知到目标链上的另一个智能合约。</li>
<li>这个合约验证事件的有效性，并在目标链上铸造 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span> 个资产 A 的代币，并转给用户 A。</li>
</ul></li>
</ul>
<hr>
<p>还有剩余两种分别是：</p>
<ul>
<li><p>原子交换（Atomic Swap）：这种类型的跨链桥利用哈希时间锁（Hash
Time
Lock）的技术，实现两个用户之间的点对点交换。哈希时间锁是一种加密合约，要求用户在一定时间内提供一个密码，否则交易会自动取消。原子交换的过程如下：</p>
<ul>
<li>用户 A 生成一个随机密码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>，并计算其哈希值 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.63ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7350.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mspace" transform="translate(1933.8,0)"></g><g data-mml-node="mi" transform="translate(2211.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(2572.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(3038.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(3610.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3971.6,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1105,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1574,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g><g data-mml-node="mo" transform="translate(6121.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6510.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6961.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>，将 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 值发送给用户 B。</li>
<li>用户 A 在起始链上发起一个有条件的交易，向用户 B 转移 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span> 个资产 A，要求用户 B
在预设的时间内提供密码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>
才能成功，否则交易自动失败。</li>
<li>用户 B 在目标链上发起一个有条件的交易，向用户 A 转移 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 个资产 B，要求用户 A
在预设的时间内提供密码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>
才能成功，否则交易自动失败。</li>
<li>用户 A 出示密码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 接收资产
B，并同时暴露 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 给用户 B。</li>
<li>用户 B 利用密码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.02ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 451 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span> 接收资产
A，并同时验证 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.63ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7350.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mspace" transform="translate(1933.8,0)"></g><g data-mml-node="mi" transform="translate(2211.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(2572.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(3038.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(3610.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3971.6,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1105,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1574,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g><g data-mml-node="mo" transform="translate(6121.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6510.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6961.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</li>
</ul></li>
</ul>
<p>首先，我们需要在波卡网络和以太坊上部署两个智能合约，分别用于锁定和释放资产。我们假设波卡网络上有一种代币叫做DOT，以太坊上有一种代币叫做ETH。我们还需要一个中继器（relayer），它是一个可以监听两个网络上的事件并发送交易的第三方服务。</p>
<p>在波卡网络上，我们可以用Rust语言编写一个智能合约，如下所示：</p>
<pre class="rust"><code>// 引入一些必要的库
use ink_lang as ink;
use ink_prelude::vec::Vec;
use ink_storage::collections::HashMap as StorageHashMap;

// 定义一个结构体，表示跨链桥合约
#[ink::contract]
pub mod Bridge {
    // 定义一些存储变量
    #[ink(storage)]
    pub struct Bridge {
        // 合约拥有者
        owner: AccountId,
        // 资产锁定记录
        locked_assets: StorageHashMap&lt;(AccountId, u64), Balance&gt;,
        // 中继器地址
        relayer: AccountId,
        // 以太坊合约地址
        eth_contract: Vec&lt;u8&gt;,
    }

    // 定义一些事件
    #[ink(event)]
    pub struct Locked {
        #[ink(topic)]
        sender: AccountId,
        #[ink(topic)]
        recipient: Vec&lt;u8&gt;,
        #[ink(topic)]
        amount: Balance,
        #[ink(topic)]
        nonce: u64,
    }

    #[ink(event)]
    pub struct Unlocked {
        #[ink(topic)]
        sender: Vec&lt;u8&gt;,
        #[ink(topic)]
        recipient: AccountId,
        #[ink(topic)]
        amount: Balance,
    }

    // 定义一些错误信息
    #[derive(Debug, PartialEq, Eq, scale::Encode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum Error {
        NotOwner,
        NotRelayer,
        InsufficientBalance,
        InvalidAmount,
        InvalidNonce,
    }

    // 定义一些返回类型
    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;

    impl Bridge {
        // 初始化合约
        #[ink(constructor)]
        pub fn new(relayer: AccountId, eth_contract: Vec&lt;u8&gt;) -&gt; Self {
            let caller = Self::env().caller();
            Self {
                owner: caller,
                locked_assets: StorageHashMap::new(),
                relayer,
                eth_contract,
            }
        }

        // 锁定资产，从波卡转移到以太坊
        #[ink(message, payable)]
        pub fn lock(&amp;mut self, recipient: Vec&lt;u8&gt;, amount: Balance) -&gt; Result&lt;()&gt; {
            let sender = self.env().caller();
            let transferred_balance = self.env().transferred_balance();
            // 检查转账金额是否正确
            if amount == 0 || amount != transferred_balance {
                return Err(Error::InvalidAmount);
            }
            // 生成一个随机数作为交易标识符
            let nonce = self.env().random(&amp;recipient).0;
            // 记录锁定的资产
            self.locked_assets.insert((sender, nonce), amount);
            // 触发锁定事件，供中继器监听
            self.env().emit_event(Locked {
                sender,
                recipient,
                amount,
                nonce,
            });
            Ok(())
        }

        // 释放资产，从以太坊转移到波卡
        #[ink(message)]
        pub fn unlock(
            &amp;mut self,
            sender: Vec&lt;u8&gt;,
            recipient: AccountId,
            amount: Balance,
            signature: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            let caller = self.env().caller();
            // 检查调用者是否是中继器
            if caller != self.relayer {
                return Err(Error::NotRelayer);
            }
            // 检查签名是否有效
            let message = Self::hash_message(sender.clone(), recipient, amount);
            if !Self::verify_signature(message, signature, self.eth_contract.clone()) {
                return Err(Error::InvalidSignature);
            }
            // 转账给接收者
            self.env().transfer(recipient, amount).map_err(|_| Error::InsufficientBalance)?;
            // 触发释放事件
            self.env().emit_event(Unlocked {
                sender,
                recipient,
                amount,
            });
            Ok(())
        }

        // 更改中继器地址
        #[ink(message)]
        pub fn change_relayer(&amp;mut self, new_relayer: AccountId) -&gt; Result&lt;()&gt; {
            let caller = self.env().caller();
            // 检查调用者是否是合约拥有者
            if caller != self.owner {
                return Err(Error::NotOwner);
            }
            // 更新中继器地址
            self.relayer = new_relayer;
            Ok(())
        }

        // 更改以太坊合约地址
        #[ink(message)]
        pub fn change_eth_contract(&amp;mut self, new_eth_contract: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
            let caller = self.env().caller();
            // 检查调用者是否是合约拥有者
            if caller != self.owner {
                return Err(Error::NotOwner);
            }
            // 更新以太坊合约地址
            self.eth_contract = new_eth_contract;
            Ok(())
        }

        // 获取锁定的资产
        #[ink(message)]
        pub fn get_locked_assets(&amp;self, sender: AccountId, nonce: u64) -&gt; Option&lt;Balance&gt; {
            self.locked_assets.get(&amp;(sender, nonce)).copied()
        }

        // 获取中继器地址
        #[ink(message)]
        pub fn get_relayer(&amp;self) -&gt; AccountId {
            self.relayer
        }

        // 获取以太坊合约地址
        #[ink(message)]
        pub fn get_eth_contract(&amp;self) -&gt; Vec&lt;u8&gt; {
            self.eth_contract.clone()
        }

        // 计算哈希值，用于签名验证
        fn hash_message(sender: Vec&lt;u8&gt;, recipient: AccountId, amount: Balance) -&gt; Vec&lt;u8&gt; {
            let mut message = Vec::new();
            message.extend_from_slice(&amp;sender);
            message.extend_from_slice(&amp;recipient.encode());
            message.extend_from_slice(&amp;amount.encode());
            ink_env::hash_bytes::&lt;ink_env::hash::Blake2x256&gt;(&amp;message).to_bytes()
        }

        // 验证签名，用于确认以太坊合约的授权
        fn verify_signature(
            message: Vec&lt;u8&gt;,
            signature: Vec&lt;u8&gt;,
            eth_contract: Vec&lt;u8&gt;,
        ) -&gt; bool {
            // 这里省略了具体的验证逻辑，可以参考一些现有的跨链桥项目，如https://github.com/Snowfork/polkadot-ethereum/blob/main/parachain/pallets/verifier-lightclient/src/eth_utils.rs
            true
        }
    }
}</code></pre>
<p>在以太坊上，我们可以用Solidity语言编写一个智能合约，如下所示：</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 引入一些必要的库
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// 定义一个接口，表示波卡网络上的代币
interface IDOT is IERC20 {}

// 定义一个合约，表示跨链桥合约
contract Bridge {
    // 定义一些存储变量
    address public owner; // 合约拥有者
    address public relayer; // 中继器地址
    address public dot; // 波卡代币地址
    bytes public polkadotContract; // 波卡合约地址

    // 定义一些事件
    event Locked(address indexed sender, bytes indexed recipient, uint256 amount);
    event Unlocked(bytes indexed sender, address indexed recipient, uint256 amount);

    // 定义一个修饰器，用于检查调用者是否是合约拥有者
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // 定义一个修饰器，用于检查调用者是否是中继器
    modifier onlyRelayer() {
        require(msg.sender == relayer, "Not relayer");
        _;
    }

    // 初始化合约
    constructor(address _relayer, address _dot, bytes memory _polkadotContract) {
        owner = msg.sender;
        relayer = _relayer;
        dot = _dot;
        polkadotContract = _polkadotContract;
    }

    // 锁定资产，从以太坊转移到波卡
    function lock(bytes memory recipient, uint256 amount) public {
        require(amount &gt; 0, "Invalid amount");
        // 从发送者扣除相应的代币
        IDOT(dot).transferFrom(msg.sender, address(this), amount);
        // 触发锁定事件，供中继器监听
        emit Locked(msg.sender, recipient, amount);
    }

    // 释放资产，从波卡转移到以太坊
    function unlock(
        bytes memory sender,
        address recipient,
        uint256 amount,
        bytes memory signature
    ) public onlyRelayer {
        // 检查签名是否有效
        bytes32 message = keccak256(abi.encodePacked(sender, recipient, amount));
        require(
            ECDSA.recover(message, signature) == polkadotContract,
            "Invalid signature"
        );
        // 给接收者转账相应的代币
        IDOT(dot).transfer(recipient, amount);
        // 触发释放事件
        emit Unlocked(sender, recipient, amount);
    }

    // 更改中继器地址
    function changeRelayer(address newRelayer) public onlyOwner {
        relayer = newRelayer;
    }

    // 更改波卡合约地址
    function changePolkadotContract(bytes memory newPolkadotContract)
        public
        onlyOwner
    {
        polkadotContract = newPolkadotContract;
    }
}</code></pre>
<p>这样，我们就完成了两个智能合约的编写。接下来，我们需要部署这两个合约，并让中继器监听两个网络上的事件。当用户想要从波卡转移到以太坊时，他需要调用波卡合约的lock方法，并指定接收者的以太坊地址和转移的金额。这样，波卡合约会锁定用户的资产，并触发一个Locked事件。中继器会监听到这个事件，并在以太坊上调用以太坊合约的unlock方法，传入发送者的波卡地址、接收者的以太坊地址、转移的金额和波卡合约的签名。这样，以太坊合约会验证签名，并给接收者转账相应的代币，并触发一个Unlocked事件。反之，当用户想要从以太坊转移到波卡时，他需要调用以太坊合约的lock方法，并指定接收者的波卡地址和转移的金额。这样，以太坊合约会锁定用户的资产，并触发一个Locked事件。中继器会监听到这个事件，并在波卡上调用波卡合约的unlock方法，传入发送者的以太坊地址、接收者的波卡地址、转移的金额和以太坊合约的签名。这样，波卡合约会验证签名，并给接收者转账相应的代币，并触发一个Unlocked事件。</p>
<ul>
<li><p>流动性置换（Liquidity
Pool）：这种类型的跨链桥利用流动性池（Liquidity
Pool）的技术，实现在目标链上提供源链的流动性，并允许用户直接兑换原生资产。流动性池是一种去中心化交易平台（DEX）的模式，它可以让用户在不需要中介或订单簿的情况下进行交易。流动性置换的过程如下：</p>
<ul>
<li>用户 A 在起始链上调用一个智能合约，并将 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span> 个资产 A 锁定在合约中。</li>
<li>合约将用户 A 的请求发送到目标链上的另一个智能合约。</li>
<li>这个合约从流动性池中取出 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span>
个资产 A 的原生资产，并转给用户 A。</li>
</ul></li>
</ul>
<p>首先，我们需要在波卡网络和以太坊上分别部署两个智能合约，分别称为<strong>波卡桥合约</strong>和<strong>以太坊桥合约</strong>。这两个合约都需要实现一些基本的功能，如：</p>
<ul>
<li>存储跨链桥的状态，包括跨链资产的总量、已锁定资产的数量、已发行资产的数量等。</li>
<li>提供跨链桥的接口，允许用户锁定、解锁、发行、销毁跨链资产。</li>
<li>验证跨链桥的消息，确保消息的来源、目标、签名、序列号等都是有效和正确的。</li>
<li>生成跨链桥的消息，包含消息的来源、目标、签名、序列号、类型、参数等信息。</li>
<li>通过一些可信赖的中继节点，将跨链桥的消息从一个网络发送到另一个网络。</li>
</ul>
<p>为了简化起见，我们假设波卡网络和以太坊之间有一个共识机制，可以保证跨链桥的消息在两个网络之间同步和一致。我们也假设用户想要将波卡网络上的一种代币（例如DOT）跨链到以太坊上，并在以太坊上获得一个对应的代币（例如eDOT）。下面是一个可能的代码示例：</p>
<pre class="rust"><code>// 波卡桥合约
use ink_lang as ink;

#[ink::contract]
mod polka_bridge {
    // 引入一些必要的库
    use ink_env::call::FromAccountId;
    use ink_prelude::vec::Vec;
    use ink_storage::{
        collections::HashMap as StorageHashMap,
        traits::{PackedLayout, SpreadLayout},
    };

    // 定义一些常量
    const RELAY_ACCOUNT: AccountId = AccountId::from([0x01; 32]); // 中继节点账户
    const ETH_BRIDGE_ADDRESS: [u8; 20] = [0x02; 20]; // 以太坊桥合约地址
    const EDOT_ADDRESS: [u8; 20] = [0x03; 20]; // eDOT代币地址

    // 定义一些结构体
    #[derive(scale::Encode, scale::Decode, SpreadLayout, PackedLayout)]
    #[cfg_attr(feature = "std", derive(Debug, PartialEq, Eq))]
    pub struct BridgeMessage {
        source: AccountId,   // 消息来源
        target: [u8; 20],    // 消息目标
        signature: [u8; 65], // 消息签名
        nonce: u64,          // 消息序列号
        kind: u8,            // 消息类型
        payload: Vec&lt;u8&gt;,    // 消息参数
    }

    #[ink(storage)]
    pub struct PolkaBridge {
        dot_total: Balance,             // 跨链资产总量
        dot_locked: Balance,            // 已锁定资产数量
        dot_issued: Balance,            // 已发行资产数量
        dot_balances: StorageHashMap&lt;AccountId, Balance&gt;, // 用户账户余额
        message_nonce: u64,             // 消息序列号
        pending_messages: Vec&lt;Message&gt;, // 待发送消息队列
    }

    impl PolkaBridge {
        #[ink(constructor)]
        pub fn new(dot_total: Balance) -&gt; Self {
            Self {
                dot_total,
                dot_locked: 0,
                dot_issued: 0,
                dot_balances: StorageHashMap::new(),
                message_nonce: 0,
                pending_messages: Vec::new(),
            }
        }

        #[ink(message)]
        pub fn lock_dot(&amp;mut self, amount: Balance) {
            // 用户锁定DOT，准备跨链到以太坊
            let caller = self.env().caller();
            let balance = self.dot_balances.get(&amp;caller).copied().unwrap_or(0);
            assert!(balance &gt;= amount, "Insufficient balance");
            self.dot_balances.insert(caller, balance - amount);
            self.dot_locked += amount;
            // 生成一条跨链消息，通知以太坊桥合约发行eDOT
            let message = BridgeMessage {
                source: caller,
                target: ETH_BRIDGE_ADDRESS,
                signature: self.sign_message(),
                nonce: self.message_nonce,
                kind: 1, // 1表示锁定资产的消息
                payload: amount.encode(),
            };
            self.message_nonce += 1;
            self.pending_messages.push(message);
        }

        #[ink(message)]
        pub fn unlock_dot(&amp;mut self, amount: Balance) {
            // 用户解锁DOT，从以太坊返回到波卡网络
            let caller = self.env().caller();
            let balance = self.dot_balances.get(&amp;caller).copied().unwrap_or(0);
            assert!(balance + amount &lt;= self.dot_total, "Exceeding total supply");
            self.dot_balances.insert(caller, balance + amount);
            self.dot_locked -= amount;
            // 生成一条跨链消息，通知以太坊桥合约销毁eDOT
            let message = BridgeMessage {
                source: caller,
                target: ETH_BRIDGE_ADDRESS,
                signature: self.sign_message(),
                nonce: self.message_nonce,
                kind: 2, // 2表示解锁资产的消息
                payload: amount.encode(),
            };
            self.message_nonce += 1;
            self.pending_messages.push(message);
        }

        #[ink(message)]
        pub fn handle_message(&amp;mut self, message: BridgeMessage) {
            // 处理从以太坊桥合约发来的跨链消息
            let caller = self.env().caller();
            assert!(caller == RELAY_ACCOUNT, "Only relay account can call this function");
            assert!(self.verify_message(&amp;message), "Invalid message");
            match message.kind {
                3 =&gt; {
                    // 3表示发行资产的消息
                    let amount = Balance::decode(&amp;mut &amp;message.payload[..]).expect("Invalid payload");
                    assert!(self.dot_issued + amount &lt;= self.dot_locked, "Exceeding locked amount");
                    self.dot_issued += amount;
                    // 给消息来源账户增加余额
                    let source = AccountId::decode(&amp;mut &amp;message.source[..]).expect("Invalid source");
                    let balance = self.dot_balances.get(&amp;source).copied().unwrap_or(0);
                    assert!(balance + amount &lt;= self.dot_total, "Exceeding total supply");
                    self.dot_balances.insert(source, balance + amount);
                }
                4 =&gt; {
                    // 4表示销毁资产的消息
                    let amount = Balance::decode(&amp;mut &amp;message.payload[..]).expect("Invalid payload");
                    assert!(self.dot_issued &gt;= amount, "Insufficient issued amount");
                    self.dot_issued -= amount;
                    // 给消息来源账户减少余额
                    let source = AccountId::decode(&amp;mut &amp;message.source[..]).expect("Invalid source");
                    let balance = self.dot_balances.get(&amp;source).copied().unwrap_or(0);
                    assert!(balance &gt;= amount, "Insufficient balance");
                    self.dot_balances.insert(source, balance - amount);
                }
                _ =&gt; {
                    // 其他类型的消息暂不处理
                }
            }
        }

        #[ink(message)]
        pub fn relay_message(&amp;mut self) {
            // 将待发送消息队列中的消息通过中继节点发送到以太坊桥合约
            let caller = self.env().caller();
            assert!(caller == RELAY_ACCOUNT, "Only relay account can call this function");
            for message in &amp;self.pending_messages {
                // 调用中继节点的接口，将消息发送到以太坊桥合约
                let relay = Relay::from_account_id(RELAY_ACCOUNT);
                relay.send_message_to_ethereum(message.clone());
            }
            // 清空待发送消息队列
            self.pending_messages.clear();
        }

        fn sign_message(&amp;self) -&gt; [u8; 65] {
            // 签名一条跨链消息，这里简化为返回一个固定值
            [0x04; 65]
        }

        fn verify_message(&amp;self, message: &amp; BridgeMessage) -&gt; bool { 
            // 验证一条跨链消息，这里简化为检查签名是否为一个固定值 
            message.signature == [0x04; 65] } 
        }

        // 定义一个中继节点的接口
        #[ink::trait_definition]
        pub trait Relay {
            #[ink(message)]
            fn send_message_to_ethereum(&amp;self, message: BridgeMessage);
        }
</code></pre>
<p>下面的是以太坊桥可能的实现代码：</p>
<pre class="solidity"><code>// 以太坊桥合约
pragma solidity ^0.8.0;

// 引入一些必要的库
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// 定义一些常量
address constant RELAY_ACCOUNT = 0x01; // 中继节点账户
address constant POLKA_BRIDGE_ADDRESS = 0x02; // 波卡桥合约地址
address constant EDOT_ADDRESS = 0x03; // eDOT代币地址

// 定义一些结构体
struct BridgeMessage {
    address source;   // 消息来源
    address target;   // 消息目标
    bytes signature;  // 消息签名
    uint256 nonce;    // 消息序列号
    uint8 kind;       // 消息类型
    bytes payload;    // 消息参数
}

contract EthBridge {
    // 定义一些变量
    uint256 public dot_total;             // 跨链资产总量
    uint256 public dot_locked;            // 已锁定资产数量
    uint256 public dot_issued;            // 已发行资产数量
    mapping(address =&gt; uint256) public dot_balances; // 用户账户余额
    uint256 public message_nonce;         // 消息序列号
    mapping(uint256 =&gt; bool) public processed_messages; // 已处理消息记录

    constructor(uint256 _dot_total) {
        dot_total = _dot_total;
        dot_locked = 0;
        dot_issued = 0;
        message_nonce = 0;
    }

    function lock_dot(uint256 amount) public {
        // 用户锁定eDOT，准备跨链到波卡网络
        address caller = msg.sender;
        require(dot_balances[caller] &gt;= amount, "Insufficient balance");
        dot_balances[caller] -= amount;
        dot_locked += amount;
        // 销毁eDOT代币
        ERC20 eDOT = ERC20(EDOT_ADDRESS);
        eDOT.burn(amount);
        // 生成一条跨链消息，通知波卡桥合约解锁DOT
        BridgeMessage memory message = BridgeMessage({
            source: caller,
            target: POLKA_BRIDGE_ADDRESS,
            signature: sign_message(),
            nonce: message_nonce,
            kind: 3, // 3表示锁定资产的消息
            payload: abi.encode(amount)
        });
        message_nonce += 1;
        // 调用中继节点的接口，将消息发送到波卡桥合约
        Relay relay = Relay(RELAY_ACCOUNT);
        relay.send_message_to_polkadot(message);
    }

    function unlock_dot(uint256 amount) public {
        // 用户解锁eDOT，从波卡网络返回到以太坊
        address caller = msg.sender;
        require(dot_balances[caller] + amount &lt;= dot_total, "Exceeding total supply");
        dot_balances[caller] += amount;
        dot_locked -= amount;
        // 发行eDOT代币
        ERC20 eDOT = ERC20(EDOT_ADDRESS);
        eDOT.mint(caller, amount);
        // 生成一条跨链消息，通知波卡桥合约销毁DOT
        BridgeMessage memory message = BridgeMessage({
            source: caller,
            target: POLKA_BRIDGE_ADDRESS,
            signature: sign_message(),
            nonce: message_nonce,
            kind: 4, // 4表示解锁资产的消息
            payload: abi.encode(amount)
        });
        message_nonce += 1;
        // 调用中继节点的接口，将消息发送到波卡桥合约
        Relay relay = Relay(RELAY_ACCOUNT);
        relay.send_message_to_polkadot(message);
    }

        function handle_message(BridgeMessage memory message) public {
        // 处理从波卡桥合约发来的跨链消息
        address caller = msg.sender;
        require(caller == RELAY_ACCOUNT, "Only relay account can call this function");
        require(verify_message(message), "Invalid message");
        require(!processed_messages[message.nonce], "Duplicate message");
        processed_messages[message.nonce] = true;
        // 根据消息类型执行相应的操作
        if (message.kind == 1) {
            // 1表示锁定资产的消息
            uint256 amount = abi.decode(message.payload, (uint256));
            require(dot_issued + amount &lt;= dot_locked, "Exceeding locked amount");
            dot_issued += amount;
            // 给消息来源账户增加余额
            address source = message.source;
            dot_balances[source] += amount;
            // 发行eDOT代币
            ERC20 eDOT = ERC20(EDOT_ADDRESS);
            eDOT.mint(source, amount);
        } else if (message.kind == 2) {
            // 2表示解锁资产的消息
            uint256 amount = abi.decode(message.payload, (uint256));
            require(dot_issued &gt;= amount, "Insufficient issued amount");
            dot_issued -= amount;
            // 给消息来源账户减少余额
            address source = message.source;
            dot_balances[source] -= amount;
            // 销毁eDOT代币
            ERC20 eDOT = ERC20(EDOT_ADDRESS);
            eDOT.burn(amount);
        } else {
            // 其他类型的消息暂不处理
        }
    }

    function sign_message() internal returns (bytes memory) {
        // 签名一条跨链消息，这里简化为返回一个固定值
        return bytes("0x04");
    }

    function verify_message(BridgeMessage memory message) internal returns (bool) {
        // 验证一条跨链消息，这里简化为检查签名是否为一个固定值
        return keccak256(message.signature) == keccak256(bytes("0x04"));
    }
}

// 定义一个中继节点的接口
interface Relay {
    function send_message_to_polkadot(BridgeMessage memory message) external;
}</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 w33d&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;last emo boy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
            <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
            <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
            <script src="/js/fireworks.min.js"></script>
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="Last-emo-boy/Last-emo-boy.github.io"
    data-repo-id="R_kgDOJz19bw"
    data-category="Announcements"
    data-category-id="DIC_kwDOJz19b84CXd_Q"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
